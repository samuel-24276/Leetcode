# 字符串分类下的题目  

## 3.Longest substring without repeated characters最长无重复子串
>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

>示例 1:

>输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

>输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

>输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

解法：**双指针滑动窗口**，有些类似KMP，应该与之前的11.Maxarea对比，         
尤其是st值的设置，此题比较字符是否相同，从一端开始滑动窗口；        
而Maxarea是测木桶容积，从两端滑动窗口更合适

## 5. longestPalindrome最长回文子串

>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

>示例 1：

>输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

>输入: "cbbd"
输出: "bb"

解法：**动态规划**
也涉及了*二维动态数组*的定义：**`vector<vector<int>>  dp(len, vector<int>(len));`
其效果等同于

```
int** dp;
int* exp;
int len = 10;
dp = new int* [len];
for (int i = 0; i < len; ++i)
	dp[i] = new int[len];
```

令dp[i][j]表示s[i]至s[j]所表示的子串是否回文，若回文，则为1，否则为0.
情况一：若s[i]==s[j]，那么只要s[i+1]至s[j-1]是回文，则dp[i][j]=1，否则=0
情况二：若s[i]!=s[j]，那么dp[i][j]=0

边界：dp[i][i]=1,dp[i][i+1] = (s[i]==s[i+1])?1:0

根据边界初始化时，dp[i][i]和dp[i][i+1]的值容易得出，若按照i和j从小到大的顺序枚举子串两个端点，然后更新dp[i][j]，会无法保证dp[i+1][j-1]已经被计算过，无法得到正确的dp[i][j]，如dp[0][4]递推dp[1][3]时，所以需要新的枚举方式
根据递推写法从边界开始的原理，注意到边界表示的是长度为1和2的子串，且每次转移时对子串长度减1，因此不妨考虑按子串长度和子串的初始位置进行枚举，即第一遍将长度为3的子串的dp值全部求出，第二遍再求长度为4的子串的dp值...

## 6.Z_convert Z字形变换 

>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

>比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：

>L   C   I   R
E T O E S I I G
E   D   H   N
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。

>请你实现这个将字符串进行指定行数变换的函数：

>string convert(string s, int numRows);
示例 1:

>输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
示例 2:

>输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

>L     D     R
E   O E   I I
E C   I H   N
T     S     G

解法1：**按行排序**--用规律去暴力破解真的智障，浪费时间

思路：通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。

算法：
我们可以使用min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。从左到右迭代 s，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。

解法2：**按行访问**--按数学规律去访问数组，节省内存

思路：按照与逐行读取 Z 字形图案相同的顺序访问字符串。

算法
首先访问 行 0 中的所有字符，接着访问 行 1，然后 行 2，依此类推...
对于所有整数 k，行 0 中的字符位于索引 k(2⋅numRows−2) 处;
行numRows−1 中的字符位于索引 k(2⋅numRows−2)+numRows−1 处;
内部的 行 i 中的字符位于索引 k(2⋅numRows−2)+i 以及 (k+1)(2⋅numRows−2)−i 处;

## 8.8.myAtoi字符串转换成整数  

>请你来实现一个 atoi 函数，使其能将字符串转换成整数。

>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该
造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，
则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。

>说明：
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。
如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。

>示例 1:

>输入: "42"
输出: 42
示例 2:

>输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
>示例 3:

>输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
示例 4:

>输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
>示例 5:

>输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。
     因此返回 INT_MIN (−231) 。

解法：题目条件略多，因此if语句少不了，关键在于**数值是否越界的判定**,初始化一变量**flag**=false，true表示符号为正，false表示符号为负。

```
if (res > INT_MAX / 10 || (res == INT_MAX / 10 && (str[i] - '0') > INT_MAX % 10)) {                    
                    if(flag)  
                        return INT_MAX;
                    return INT_MIN;
                }
```

这段代码的精妙之处在于：INT_MAX=2147483647，INT_MIN=-2147483648，两者除10结果均相同，正好作为边界条件，且忽略正负，留在最后处理。
若`res > INT_MAX / 10`，则一定越界，根据flag确定正负；
而若`res == INT_MAX / 10 && (str[i] - '0') > INT_MAX % 10)`，则是前9位无越界，第10位出现越界，且`(str[i] - '0') > INT_MAX % 10)`能表示INT_MAX与INT_MIN两者，简化了代码。

但是，题目中没有明说的一种情况是：连续多次出现+、-,则返回0。
**flag**的值不能只有二重性了，还要表示是否出现过符号，所以用int型，0表示未曾出现符号。

```
if (res > INT_MAX / 10 || (res == INT_MAX / 10 && (str[i] - '0') > INT_MAX % 10)) {                    
                    if(flag==1 || flag==0)  //若数字前仅出现一次+或0次+
                        return INT_MAX;
                    if(flag==-1)            //若数字前出现一次-
                        return INT_MIN;
                }
```

与此同时，判读符号的if分支也要增加代码量。

```
//若前面出现过一次符号，这次又是符号，直接返回0
//若符号后字符不是数字，直接返回0
if (flag || str[i + 1] < '0' || str[i + 1]>'9')       
                    return 0;
                if (str[i] == '-')                     
                    flag = -1;                   
                else                   
                    flag = 1;
```