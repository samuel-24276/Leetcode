# 字符串分类下的题目  

## 3.Longest substring without repeated characters最长无重复子串
>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

>示例 1:

>输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

>输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

>输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

解法：**双指针滑动窗口**，有些类似KMP，应该与之前的11.Maxarea对比，         
尤其是st值的设置，此题比较字符是否相同，从一端开始滑动窗口；        
而Maxarea是测木桶容积，从两端滑动窗口更合适

## 5. longestPalindrome最长回文子串

>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

>示例 1：

>输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

>输入: "cbbd"
输出: "bb"

解法：**动态规划**
也涉及了*二维动态数组*的定义：**`vector<vector<int>>  dp(len, vector<int>(len));`
其效果等同于

```
int** dp;
int* exp;
int len = 10;
dp = new int* [len];
for (int i = 0; i < len; ++i)
	dp[i] = new int[len];
```

令dp[i][j]表示s[i]至s[j]所表示的子串是否回文，若回文，则为1，否则为0.
情况一：若s[i]==s[j]，那么只要s[i+1]至s[j-1]是回文，则dp[i][j]=1，否则=0
情况二：若s[i]!=s[j]，那么dp[i][j]=0

边界：dp[i][i]=1,dp[i][i+1] = (s[i]==s[i+1])?1:0

根据边界初始化时，dp[i][i]和dp[i][i+1]的值容易得出，若按照i和j从小到大的顺序枚举子串两个端点，然后更新dp[i][j]，会无法保证dp[i+1][j-1]已经被计算过，无法得到正确的dp[i][j]，如dp[0][4]递推dp[1][3]时，所以需要新的枚举方式
根据递推写法从边界开始的原理，注意到边界表示的是长度为1和2的子串，且每次转移时对子串长度减1，因此不妨考虑按子串长度和子串的初始位置进行枚举，即第一遍将长度为3的子串的dp值全部求出，第二遍再求长度为4的子串的dp值...

## 6.Z_convert Z字形变换 

>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

>比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：

>L   C   I   R
E T O E S I I G
E   D   H   N
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。

>请你实现这个将字符串进行指定行数变换的函数：

>string convert(string s, int numRows);
示例 1:

>输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
示例 2:

>输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

>L     D     R
E   O E   I I
E C   I H   N
T     S     G

解法：**按行排序**--用规律去暴力破解真的智障，浪费时间

思路：通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。

算法：
我们可以使用min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。从左到右迭代 s，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。