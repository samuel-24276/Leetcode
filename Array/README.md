# 数组分类下的Leetcode题目

## 1.twoSum--两数之和
> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

>示例:

>给定 nums = [2, 7, 11, 15], target = 9

>因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]          
      
解法：题目要求返回下标，不好进行排序，直接双重for循环**暴力破解** 
   

## 4.findMedianSortedArrays--寻找两个有序数组的中位数
>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

>你可以假设 nums1 和 nums2 不会同时为空。

>示例 1:

>nums1 = [1, 3]
nums2 = [2]

>则中位数是 2.0
示例 2:

>nums1 = [1, 2]
nums2 = [3, 4]

>则中位数是 (2 + 3)/2 = 2.5

解法：找中位数可以先把两个有序数组进行**合并排序**，然后找到判断元素总数是奇数还是偶数，奇数直接返回下标为len/2的元素，偶数则需要返回中间两个元素的平均值。注意：除法用/且参数为int型，则得到商；要得到精确值，需在=右边，参数左边加上(double)，进行类型转换，这点很容易出错。


## 11.MaxArea盛最多水的容器 
>给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) .在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水.
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7].在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49.
说明：你不能倾斜容器，且 n 的值至少为 2.

>示例：

>输入：[1,8,6,2,5,4,8,3,7]
>输出：49

解法：**暴力破解->双指针->倒序遍历(类似二叉树剪枝)**          
此题属于贪心算法，寻找最优值，最好用双指针，容易理解。   
倒序遍历法：对于双重循环for(i,j),无需遍历内层循环[i,n-1]、[i,n-2]、...[i,0]时，可以使用j=i+1跳出循环；无需遍历外层循环[0,j]、[1,j]、...[n-1,j]时，需要预设变量st=size()-1,j=st来初始化，详细的请看代码  
      

简单反证法证明：通过双指针方法，两个指针一定会同时经过最大面积对应的指针位置。

                                                           
                  |                     
           |      |                     
           |      |                     
     ......|......|......               
——————————————————————————————————————— 
           m      n
如图，若m,n之间的面积为最大面积。

双指针方法的规律是：每次都会向内移动偏矮的指针（可观察案例）。要证明两个指针一定会移动到m和n位置，只需证明：

m左侧的指针点等于或矮于n，n右侧指针等于或矮于m。

假设m左侧有一个点p，高度高于n.

                                        
        |                                
        |          |                     
        |   |      |                     
        |   |      |                     
     ...|...|......|......               
——————————————————————————————————————— 
        p   m      n
因为:

    AreaMN = ( n - m ) * min( arr[ m ], arr[ n ] )
    AreaPN = ( n - p ) * min( arr[ p ], arr[ n ] )
又：

    (  n - m ) <= ( n - p )
    min( arr[ m ], arr[ n ] ) <= min( arr[ p ], arr[ n ] )
所以： AreaMN < AreaPN, 与m和n构成最大面积相矛盾，所以假设不成立，即m左侧的点都不高于n，即等于或矮于n。同理可证，n右侧指针等于或矮于m。所以通过双指针方法，两个指针一定会同时经过最大面积对应的指针位置。】


## 15.threeSum三数之和
>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

>注意：答案中不可以包含重复的三元组。

>示例：

>给定数组 nums = [-1, 0, 1, 2, -1, -4]，

>满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]           

解法：**双指针**
三数之和可以解构成在二数之和问题的基础上，将target值变成变化的值。对数组进行遍历，每一个元素的值就是target的取值。
过程中的小技巧：

为保证不重复，首先对数组进行排序，但不可去重。当target取值相同时，直接跳过即可，这是保证不重复需要注意的其中一点。另一点是在寻找两数之和满足target值时，若遇到相同元素（相同元素一定相邻），可直接跳过。

用map结构求满足条件的两数时，时间复杂度是O(NlgN);用hash_map时，时间负责度是O(N);用双指针的时间复杂度也是O(N).三数之和即在二数的基础上再乘N的复杂度。本人尝试过，若用map结构解该题会报超时。
用双指针是相对合适的解法，原因是双指针遍历时，可以结合先剪枝策略，从而降低平均耗时。
先剪枝策略：前面的指针所访问的元素大于target时，可提前结束。
过程中的注意事项：

边界判断：数组长度不得小于3
第一个元素大于0或最后一个元素小于0时，直接结束，返回空数组


## 16.closestThreeSum最接近的三数之和   
 
>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).

解法：是15题三数之和的普化版本，依旧采用**双指针**，答案唯一，不必去重
预设变量closeSum=前三数之和，进入while(l<r)循环，
循环内另设变量threeSum=nums[i]+nums[l]+nums[r];
因为寻最接近之和故须abs()绝对值函数，若abs(closeSum - target) > abs(threeSum - target)，则说明threeSum与target更接近，closeSum=threeSum;
接下来是熟悉的环节，通过比较threeSum和target大小确定左右指针方向，
直至相等时返回target


## 18.fourSum四数之和 
>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

>注意：答案中不可以包含重复的四元组。

>示例：

>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

>满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]

解法：与15题三数之和类似，是其升级版，依旧使用**双指针。**
先边界判定，数组大小小于四，直接返回空白向量。
之后比三数之和多一重循环，故多一变量j，二重循环for(i,j)，
循环内while(l<r),初值i=0,j=i+1,l=j+1,r=size()-1.
while()循环内依旧，四数之和小于target则++l,大于则--r,等于则进栈，同时变化左右指针，++l，--r,防止死循环。

另一关键是**去重**，与三数之和对比发现，n数之和需要n-1层循环，1层为while(l<r)循环，n-2层为for()循环，每层循环内都需要进行去重（当前元素与下一元素或上一元素对比，若相等则continue跳过），while()循环内的去重同样用while()多次去重，变化指针指向。

