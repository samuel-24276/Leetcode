# 数组分类下的Leetcode题目

# 1.twoSum--两数之和
> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]         
**解法：题目要求返回下标，不好进行排序，直接双重for循环暴力求解**     
# 4.findMedianSortedArrays--寻找两个有序数组的中位数
>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

**解法：找中位数可以先把两个有序数组进行合并排序，然后找到判断元素总数是奇数还是偶数，奇数直接返回下标为len/2的元素，偶数则需要返回中间两个元素的平均值。注意：除法用/且参数为int型，则得到商；要得到精确值，需在=右边，参数左边加上(double)，进行类型转换，这点很容易出错。**
# 11.MaxArea盛最多水的容器 
>给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) .在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水.
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7].在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49.
说明：你不能倾斜容器，且 n 的值至少为 2.

>示例：

>输入：[1,8,6,2,5,4,8,3,7]
>输出：49

**解法：暴力破解->双指针->倒序遍历(类似二叉树剪枝)          
此题属于贪心算法，寻找最优值，最好用双指针，容易理解。   
倒序遍历法：对于双重循环for(i,j),无需遍历内层循环[i,n-1]、[i,n-2]、...[i,0]时，可以使用j=i+1跳出循环；无需遍历外层循环[0,j]、[1,j]、...[n-1,j]时，需要预设变量st=size()-1,j=st来初始化，详细的请看代码**   
简单反证法证明：通过双指针方法，两个指针一定会同时经过最大面积对应的指针位置。

                                                           
                  |                     
           |      |                     
           |      |                     
     ......|......|......               
——————————————————————————————————————— 
           m      n
如图，若m,n之间的面积为最大面积。

双指针方法的规律是：每次都会向内移动偏矮的指针（可观察案例）。要证明两个指针一定会移动到m和n位置，只需证明：

m左侧的指针点等于或矮于n，n右侧指针等于或矮于m。

假设m左侧有一个点p，高度高于n.

                                        
        |                                
        |          |                     
        |   |      |                     
        |   |      |                     
     ...|...|......|......               
——————————————————————————————————————— 
        p   m      n
因为:

    AreaMN = ( n - m ) * min( arr[ m ], arr[ n ] )
    AreaPN = ( n - p ) * min( arr[ p ], arr[ n ] )
又：

    (  n - m ) <= ( n - p )
    min( arr[ m ], arr[ n ] ) <= min( arr[ p ], arr[ n ] )
所以： AreaMN < AreaPN, 与m和n构成最大面积相矛盾，所以假设不成立，即m左侧的点都不高于n，即等于或矮于n。同理可证，n右侧指针等于或矮于m。所以通过双指针方法，两个指针一定会同时经过最大面积对应的指针位置。